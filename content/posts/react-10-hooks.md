---
title: "10 hooks de React expliqu√©s"
date: 2022-04-15T12:47:26+02:00
tags: ["react", "javascript", "framework", "hooks"]
description: "Comment fonctionnent les 10hooks les plus communs de React"
---

## Introduction

Le "state" correspond en fait au jeu de donn√©es qui est utilis√© par le composant et qui est conserv√© m√™me si le composant est re-render.

Initialement les composants React √©taient des classes. Cette approche est toujours possible, mais maintenant il est conseill√© d'utiliser des composant sous forme de Fonction.

Le state √©tait √©troitement li√© √† la classe du composant et de nombreuses features √©taient li√©es au type "classe" des composants. Les hooks permettent d'acc√©der √† ces features sur des composants de type fonction, et souvent plus simplement qu'avant.

Un hook n'est rien de plus qu'une **fonction** dont le nom commence par **use**: `useSuperPower()` et permet de faire un action sp√©cifique.

10 hooks sont fournis par d√©faut par React, et il est possible d'en cr√©er des customs. PAr conventions, on nommera ces hooks customs avec un nom commen√ßant par **use**.

> Il y a un r√®gle importante √† garder en t√™te lorsqu'on utilise des hooks : toujours les appeler au plus haut niveau d'une fonction composant, jamais "nest√©" dans une sous-fonction ou un boucle ou autre.  
> Exception: les hooks custom, qui d√©pendent forcment de la mani√®re dont on a cod√© le hook!

## 1. useState()

### D√©finition

Le state ne peut pas √™tre modifi√© directement, le state peut √™tre consd√©r√© comme une constante dans la fonction, il faut passer par le **hook** `useState()`.

useState() permet de changer le state.

> NB: lorsque le state change, le composant est re-render

### Syntaxe

```jsx
const [truc, setTruc] = useState(valInitiale);
// truc : la variable du state
// setTruc : la focntion qui permet de changer le state : on lui passe en param la nouvelle valeur de la variable du state
// valInitiale : la valeur initiale de la variable du state
```

On utilise les crochets car on utilise la d√©structuration (ou "d√©composition" pour les array).. on aurait tr√®s bien pu faire:

```jsx
const trucArray = useState(valInitiale);
const truc = trucArray[0];
const setTruc = trucArray[1];
// => √ßa marche mais c'est moche !
```

### Exemple

```jsx
function Cart() {
  const itemPrice = 8;
  const [cart, updateCart] = useState(0);
  const [isOpen, setIsOpen] = useState(false);

  return isOpen ? (
    <div className="lmj-cart">
      <button onClick={() => setIsOpen(false)}>Fermer</button>
      <h2>Panier</h2>
      <div>
        Monstera : {itemPrice}‚Ç¨
        <button onClick={() => updateCart(cart + 1)}>Ajouter</button>
      </div>
      <h3>Total : {itemPrice * cart}‚Ç¨</h3>
    </div>
  ) : (
    <button onClick={() => setIsOpen(true)}>Ouvrir le Panier</button>
  );
}
```

### "Faire remonter" le state

Dans ce cas, le `useState()` sera d√©fini dans un composant parent, le state sera pass√© au composant enfant dans les props, ainsi que la fonction d'update.  
Cela permet de "partager" le state entre diff√©rents composants enfants.

```jsx
function ParentComponent() {
  const [truc, updateTruc] = useState("truc initial");

  return (
    <div>
      <ChildComponent1 truc={truc} updateTruc={updateTruc} />
      <ChildComponent2 truc={truc} updateTruc={updateTruc} />
    </div>
  );
}

function ChildComponent1({ truc, updateTruc }) {
  return (
    <div>
      <p>mon truc: {truc}</p>
      <button onClick={() => updateTruc("autre truc")}>change truc 1</button>
    </div>
  );
}

function ChildComponent2({ truc, updateTruc }) {
  return (
    <div>
      <p>mon truc: {truc}</p>
      <button onClick={() => updateTruc("encore un autre truc")}>
        change truc 2
      </button>
    </div>
  );
}
```

## 2.useEffect()

### D√©finition

Permet d'ex√©cuter une fonction

- soit √† chaque fois que le composant est re-render (= √† chaque fois que le state change)
- soit lorsque une/des variable(s) sp√©cifique(s) du state change
- soit une fois au premier render

### Syntaxe

```jsx
useEffect(callback, []);

// 1er param obligatoire: la fonction qui sera ex√©cut√©e
// 2eme param optionnel: le tableau de d√©pendance
```

### R√®gles du tableau de d√©pendance

- `useEffect(callback)` : si aucun 2eme param√®tre n'est pass√©, le callback est appel√© √† chaque fois que le composant est render
- `useEffect(callback, [toto, tutu])` : si un tableau de d√©pendance est pass√© en 2eme argument, le callback ne sera appel√© que si les variables sp√©cifi√©es (toto et tutu dans l'exemple..) sont modifi√©es avec useState()
- `useEffect(callback, [])` : si un tableau vide est pass√©, le callback sera ex√©cut√© seulement un premier render du composant.

### callback √† la suppression du composant

Il est aussi possible d'ex√©cuter une fonction au "d√©montage" du composant. Pour cela, le callback doit **return** une autre fonction qui sera ex√©cut√©e juste avant la suppression du composant du DOM :

```jsx
useEffect(() => {
  console.log("affich√© √† chaque fois que le state change");

  return () => {
    console.log("affich√© au d√©montage du composant");
  };
});
```

## 3. useContext()

### D√©finition

Permet d'utiliser **l'API contexte** de React, qui permet de partager des props, sans devoir les passer d'un composant parent, √† son enfant, √† son petit-enfant, etc.

### Exemple

```jsx
const moods = {
  happy: ":)",
  sad: ":(",
};

const MoodContext = createContext(moods);

function App() {
  return (
    <MoodContext.Provider value={moods.happy}>
      <MoodEmoji />
    </MoodContext.Provider>
  );
}

function MoodEmoji() {
  const mood = useContext(MoodContext); // utilise la valeur donn√©e par le provider parent le plus proche

  return <p>{mood}</p>;
}
```

Si la valeur change dans le provider parent, alors le composant enfant utilisant ce context sera mis √† jour automatiquement.

### Exemple plus r√©aliste: dark mode qui ne change que le Main du site

```jsx
// fichier ThemeProvider.jsx
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState("light");
  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light");
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// fichier App.jsx : on englobe tous les composant du site dans ce provider
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main>
        <Composant1 />
        <Composant2 />
        <Composant3 />
        <LightSwitch />
      </Main>
    </ThemeProvider>
  );
}

// Dans le composant Main on va r√©cup√©rer le theme et afficher la bonne classe selon qu'il est "light" ou "dark"
import { ThemeContext } from "../context/ThemeProvider";
function Main() {
  const { theme } = useContext(ThemeContext);

  return (
    <main style={theme === "dark" ? "background-color: black;" : ""}>
      {children}
    </main>
  );
}

// Puis dans le composant LightSwitch
function LightSwitch() {
  const { toggleTheme, theme } = useContext(ThemeContext);
  return (
    <button onClick={() => toggleTheme()}>
      Changer de mode : {theme === "light" ? "‚òÄÔ∏è" : "üåô"}
    </button>
  );
}
```

## 4. useRef()

Permet de cr√©er un objet mutable qui va garder la m√™me r√©f√©rence entre les renders, mais qui ne provoque pas un re-render de la page lorsque sa valeur change.

La valeur actuelle est accessible avec `maVariable.current`

```jsx
function App() {
  // Dans ce cas, la valeur est bien mise √† jour √† chaque click sur le bouton
  // Mais elle n'est jamais affich√©e (il y a toujours "0" dans le bouton) car le changement de valeur n'implique pas un re-render du composant
  const count = useRef(0);

  return (
    <button onClick={() => count.current++}>
      Ma valeur:
      {count.current}
    </button>
  );
}
```

En pratique, ce hook est souvent utilis√© pour r√©cup√©rer un √©lement html du DOM grace √† l'attribut `ref` dans le html:

```jsx
function App() {
  const myBtn = useRef(null);
  const clickIt = () => myBtn.current.click();
  return <button ref={myBtn}>mon bouton</button>;
}

// dans ce cas, quand la fonction clickIt() est appel√© (par une autre m√©thode), alors le bouton est cliqu√©.
```

## 5. useReducer()
